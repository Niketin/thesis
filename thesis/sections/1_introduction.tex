%!tex root = ../main.tex

\section{Introduction}  \label{sec:introduction}

Large problems often require large computational capacity.
Distributed computing is \emph{any kind} of computing that is performed on a spatially distributed system~\cite{DBLP:books/el/leeuwen90/LamportL90}.
Distributed computing is often considered when high amounts of computation power is required.
It is used to solve large scale problems that would otherwise be impractical to solve in a centralized system.

In this thesis, we study the theoretical foundations of distributed computing.
Commonly, the research in the field focuses on distributed algorithms and complexity classes of distributed graph problems.
%Our main focus is on locally checkable labeling (LCL) problems, which is a certain class of distributed graph problems.
A distributed algorithm is a program that is executed in a distributed system.
Different computation models are used as an abstraction of these distributed systems.
The models we are particularly interested in are the port-numbering (PN) model~\cite{DBLP:conf/stoc/Angluin80} and the LOCAL model~\cite{DBLP:conf/focs/Linial87}.
In these models, computation is done in synchronous communication rounds that consist of message passing.
A communication round is the unit of time used in measuring a complexity of an algorithm in these models.

Our main focus is on a certain class of distributed graph problems called locally checkable labeling (LCL) problems.
LCL problems are a family of graph problems where a global solution can be verified locally by the individual nodes.
For example, in graph coloring, each node checks that their neighbors do not share the color of the node.

%We find LCL problems interesting, because a global result of a computation can be checked locally by each node.
%If all nodes agree that their local neighborhood of nodes are looking valid, then the result is also a globally valid solution.

%We want to know how fast LCL problems can possibly be solved
To understand the exact complexities of LCL problems in these models, we focus on finding lower bounds for them.
Finding new lower bounds for some LCL problems can potentially help us to figure out a general rule on why these LCL problems have their specific lower bound.
One way of proving a lower bound is to construct a problem instance which requires some amount of communication rounds to be solved.
Finding a lower bound requires some kind of proof of existence, and proving it manually can be tiresome, so instead we want to automate the process.

\subsection{Objective}
In this thesis, we prove that an unsolvability of an LCL problem in the PN model implies that the problem is also not solvable in constant time in the LOCAL model.
We will also implement a tool that can automatically find a proof of unsolvability of an LCL problem in the PN model.
Using these two, we can derive lower bounds in the LOCAL model.
We especially want this tool to be usable in practice, therefore it needs to be optimized to compute results reasonably fast.
To conclude, our objective is to find automatically new lower bounds for LCL problems in the LOCAL model.

\subsection{Organization of the thesis}
We organize the thesis as follows.
In Section~\ref{sec:background}, we give a succinct theoretical background to the topic of this work.
After the theoretical background, we present our research questions in more detail in Section~\ref{sec:research_question}.
In Section~\ref{sec:prior_work}, we overview the prior work related to the problems and models discussed in this thesis.
We introduce our algorithm and also prove our main theorem (Theorem~\ref{thm:lcl_unsolvability}) in Section~\ref{sec:algorithm}.
In Section~\ref{sec:implementation}, we discuss our implementation of the algorithm.
%The algorithm is used in our implementation, which we discuss in Section~\ref{sec:implementation}.
The results from our thesis are presented in Section~\ref{sec:results}, and finally we conclude the thesis in Section~\ref{sec:summary}.
