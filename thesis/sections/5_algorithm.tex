%!tex root = ../main.tex

\section{Algorithm} \label{sec:algorithm}

In this section, we will introduce the basic idea of an essential algorithm that is used in the actual implementation discussed in section \ref{sec:implementation}.
The algorithm's purpose is to find a proof that a given LCL problem $\Pi$ is impossible to solve in PN model.
Here we specifically allow PN networks to have multiple connections.
Later we show that the unsolvability of a problem $\Pi$ in PN networks (with multiple connections) implies that it is also impossible to solve $\Pi$ in \emph{simple} PN networks (without multiple connections).
Finally we show that the unsolvability of $\Pi$ in \emph{simple} PN networks implies that $\Pi$ is not solvable in constant time ($\mathcal{O}(1)$) in the LOCAL model.

%TODO These definitions and theorems might have a better place under section 2 background.
\begin{definition} \label{def:lcl_solvability}
    An LCL problem $\Pi$ is solvable in PN model, if and only if there exists a PN algorithm $A$ that finds a solution for $\Pi$ in all PN networks.
\end{definition}

We can define an alternative version of the Definition \ref{def:lcl_solvability} using contraposition.
\begin{definition} \label{def:lcl_solvability:contrapositive}
An LCL problem $\Pi$ \textbf{is not solvable} in PN model, if and only if there \textbf{does not exist} a PN algorithm $A$ that finds a solution for $\Pi$ in all PN networks.
\end{definition}

The Definitions \ref{def:lcl_solvability} and \ref{def:lcl_solvability:contrapositive} are equivalent. The latter one might be more difficult to understand, but the way it is phrased, easily leads us to the following Theorem:

\begin{theorem} \label{thm:lcl_nonsolvability}
    An LCL problem $\Pi$ is not solvable in PN model, if there exists a PN network $N$ such that no PN algorithm $A$ can solve the $\Pi$ in $N$.
\end{theorem}
\begin{proof}
    Let $\Pi$ be an LCL problem.
    Let $N$ be a PN network such that no PN algorithm $A$ can solve $\Pi$ in $N$.
    Therefore no PN algorithm $A$ can find a solution to $\Pi$ in all PN networks.
    According to the definition \ref{def:lcl_solvability:contrapositive}, this is equivalent with $\Pi$ being unsolvable.
\end{proof}

As the Theorem \ref{thm:lcl_nonsolvability} shows us, to show that a problem $\Pi$ is unsolvable, it is enough to find a counterexample, a PN network $N$ in which the problem $\Pi$ cannot be solved.
To show that, it is enough to find an underlying graph $G$ of $N$ in which the problem $\Pi$ cannot be solved.
Using this fact, we can come up with an algorithm that automatically tries to find an counterexample graph.

\begin{algorithm}[H]
    \caption{Counterexample graph finder algorithm}
    \label{alg:counterexample_finder}
    \begin{algorithmic}[1] % The number tells where the line numbering should start
        \Require $1 \leq n_{low} \leq n_{high}$
        %\Require $\Pi$ is an LCL problem
        \Function{Find}{$n_{low},n_{high}, \Pi$} \Comment{Graph bounds $n_{low}$ and $n_{high}$, LCL problem $\Pi$} \label{alg:counterexample_finder:n_loop}
            \State $d_a \gets \textsc{ActiveDegree}(\Pi)$ \label{alg:counterexample_finder:d_a}
            \State $d_p \gets \textsc{PassiveDegree}(\Pi)$ \label{alg:counterexample_finder:d_p}
            \For{$n\gets n_{low}, n_{high}$} \Comment{Iterate graph sizes from lowest to highest} \label{alg:counterexample_finder:n}
                \State $G_n \gets \textsc{GenerateGraphs}(n, d_a, d_p)$ \label{alg:counterexample_finder:Gn}
                \ForEach{$g \in G_n$} \label{alg:counterexample_finder:g}
                    \If {$\textsc{IsUnsolvable}(\Pi, g)$} \label{alg:counterexample_finder:is_unsolvable}
                        \State \Return $g$ \label{alg:counterexample_finder:return_g}
                    \EndIf
                \EndFor
            \EndFor
            \State \Return \Comment{No counterexample found. Return nothing.} \label{alg:counterexample_finder:return_nothing}
        \EndFunction
    \end{algorithmic}
\end{algorithm}

The Algorithm \ref{alg:counterexample_finder} is designed to find the smallest counterexample graph for an LCL problem $\Pi$.
It starts from graphs of size $n_{low}$ and goes up to graphs of size $n_{high}$.
%TODO define what is a graph's size, in 2. background.
We define $d_a$ and $d_p$ to be the active and passive degree of the problem $\Pi$ respectively (rows \ref{alg:counterexample_finder:d_a} and \ref{alg:counterexample_finder:d_p}).
The variable for the current graph size is called $n$ (row \ref{alg:counterexample_finder:n}).
For each graph size $n$, we generate all possible $(d_a, d_p)$-biregular multigraphs with $\textsc{GenerateGraphs}(n, d_a, d_p)$, and save the graphs into variable $G_n$ (row \ref{alg:counterexample_finder:Gn}).
The reason for generating only these types of graphs comes from our definition of LCL problem from section \ref{sec:lcl_problems}, they are defined specifically for $(b,a)$-biregular (multi)graphs.
%TODO make sure that it defines the LCL problems we are using here (LCL for (b,a)-biregular graphs)
Now, for each graph $g \in G_n$ (row \ref{alg:counterexample_finder:g}) we check if the given problem $\Pi$ is unsolvable using the function $\textsc{IsUnsolvable}(\Pi, g)$ (row \ref{alg:counterexample_finder:is_unsolvable}).
If it is unsolvable, we return the graph as an counterexample (row \ref{alg:counterexample_finder:return_g}).
In the case there are no counterexamples in graphs of size $n_{low}$ to $n_{high}$, the algorithm returns nothing (row \ref{alg:counterexample_finder:return_nothing}).

Up to this moment, we have not discussed about how the function $$\textsc{GenerateGraphs}(n, d_a, d_p)$$ from row \ref{alg:counterexample_finder:Gn} generates the graphs, nor have we discussed about how the function $$\textsc{IsUnsolvable}(\Pi, g)$$ from row \ref{alg:counterexample_finder:is_unsolvable} determines the unsolvability used in the Algorithm \ref{alg:counterexample_finder}.
These functions are implementation specific and in this section we assume that they exist as black boxes.
Later on the section \ref{sec:implementation} we introduce our implementations of these functions.
%First we would like to discuss about the $\textsc{GenerateGraphs}(n)$.
%As we know from the section \ref{}, %TODO refer to LCL section and make sure that it defines the LCL problems we are using here (LCL for (b,a)-biregular graphs).
%the LCL problems used in this thesis are defined for $(b,a)$-biregular graphs.
%Therefore we should not generate \emph{all} graphs but only the graphs of type $(b,a)$-biregular, where the degrees $b$ and $a$ are taken from the LCL problem $\Pi$.



%TODO talk about graphs, why they are actually (b, a)-biregular multigraphs.
%TODO talk about networks and graphs. In the above text they are refered as if they were the same thing.
%TODO Do we need to talk about trees and how these biregular multigraphs relate to them? 'Informally, the idea is to prove negative results for the case in which "we are in the middle of a very large tree, far away from the leaves".'

\subsection{\todo{Couple implications}}
In this section we show that if an LCL problem is not solvable in PN networks with multiple connections, then the problem is also not solvable in simple PN networks.
We try to split this into couple of theorems and at the end utilize the shown theorems to show this to be true.

% Pi is nonsolvable in multiple connection PN network N -> Pi is nonsolvable in lift of N
\begin{theorem} \label{thm:lcl_nonsolvability:2}
If an LCL problem $\Pi$ is not solvable in PN network $N$, then it is also not solvable in any PN network $N'$ that is a lift of $N$.
\end{theorem}
\begin{proof}
    Let problem $\Pi$ have no solution in some PN network $N$.
    Then any algorithm $A$ produces a result that is nonvalid solution to $\Pi$ i.e. a local constraint is violated at least at some node $v$.
    Let $\phi: V' \rightarrow V$ be a covering map from $N'=(V', P', p')$ to $N=(V, P, p)$
    Theorem 7.1. \footnote{\todo{should I show the theorem or is this enough?}} from the text book \cite{HirvonenSuomelaDistAlg2020} shows that the nodes of $N'$ will have exactly the same state as their counterparts at $N$ for each time unit $t=0,1,...$.
    Hence if we run algorithm $A$ on both networks $N$ and $N'$, the local constraint violation at some node $v \in N$ also appears in all nodes $v' \in V'$ such that $\phi(v') = v$ i.e. the local constraint violations also appear in the covering network $N'$.
\end{proof}

% Network with multiple connections ----k-lift--->  simple network
\begin{theorem} \label{thm:lcl_nonsolvability:3}
    If there is a PN network $N$ with multiple connections with $k$ being the highest count of multiple connections between any two nodes, then there exists a $k$-lift $N'$ of $N$ such that $N'$ is a simple PN network.
\end{theorem}
\begin{proof}
    Let $N=(V, P, p)$ be a PN network with multiple connections.
    Let $\operatorname{mul}(u, v)$ be the number of connections between any nodes $u, v \in V$.
    Let $k=\max {m(u, v) | u, v \in V}$ i.e. the maximum number of multiple connections.
    \footnote{\todo{Is the "maximum number of multiple connections" ambiguous? Does it appear as the highest count of parallel connections or as the total number of multiple connections in the network?}}

    Let there be another network $N'=(V', P', p')$ such that:
    \begin{itemize}
        \item For each $v \in V$, there are $k$ clones, namely the nodes $v_1, v_2, ..., v_k \in V'$.
            Thus the size $|V'|$ is $k|V|$.
        \item For each port $(v, i) \in P$, we have port $(v_x, i) \in P'$ where $x=1, 2, ..., k$.
        \item For each non multiple connection $p((v, i)) = (u, j)$, we have a connections $p'((v_x, i)) = (u_x, j)$, where $x=1, 2, ..., k$.
        \item For each multiple connections $p((v, i_a)) = (u, j_a)$ and each $a = 1, 2, ..., \operatorname{mul}(u, v)$, we have $p'((v_{x}, i_a)) = (u_{x+a-1}, j_a)$.
    \end{itemize}

    Now we show that $N'$ is a simple PN network.

    Finally we need to show that there is a covering map $\phi: V' \rightarrow V$.
    \todo{Complete this proof}
    Function $\phi$ is a covering map, therefore $V'$ is a k-lift of $V$.

\end{proof}

\begin{figure}[H]
 \centering
 \includegraphics[]{example-image-duck}
 \caption{Illustration of k-lift using Theorem \ref{thm:lcl_nonsolvability:3} }
 \label{fig:duck2}
\end{figure}
%% This is more like an instruction on how to build the network, not a proof or is it?

    % Let $N=(V, P, p)$ be a PN network with multiple connections.
    % Let $m(u, v)$ be the number of connections between any nodes $u, v \in V$.
    % Let $k=\max {m(u, v) | u, v \in V}$ i.e. the maximum number of multiple connections.
    % \footnote{\todo{Is the "maximum number of multiple connections" ambiguous? Does it appear as the highest count of parallel connections or as the total number of multiple connections in the network?}}

    %Let's construct a new network $N'=(V', P', p')$ that consists of $k$ copies of $N$.
    %Initially the network $N'$ is not connected and therefore it is not a valid PN network but lets ignore this for now as the network gets valid soon as we alter it.
    %For each connection (v', j')
%
    %Let $\phi: V' \rightarrow V$ be a surjection such that for each node $v_i \in V'$ where $i=1, 2, ..., k$, $\phi(v_i) = v \in V$.
    %Next, we will swap the ends of connections such that the network becomes connected and 
    %\todo{Complete this proof}
% Pi is nonsolvable in multiple connection PN network N -> Pi is nonsolvable in simple PN network N' (lift of N)
\begin{theorem} \label{thm:lcl_nonsolvability:4}
    If an LCL problem $\Pi$ is not solvable in PN network $N$ with multiple connections, then it is also not solvable in simple PN network $N'$ that is a lift of $N$.
\end{theorem}
\begin{proof}
    \todo{Complete this proof}
\end{proof}



\begin{theorem}
    If a problem is not solvable in simple PN networks, then it is not solvable in constant ($\mathcal{O}(1)$) time in the LOCAL model.
    %TODO Make sure that the LOCAL model is explained under section 2. background.
    %TODO Make sure that the solving complexities (($\mathcal{O}(1)$) time) are explained under section 2. background.
\end{theorem}
\begin{proof}
    \todo{Complete this proof} %TODO Complete this proof
\end{proof}